/* automatically generated by rust-bindgen 0.63.0 */

pub const MDB_FMT_Z: &[u8; 2usize] = b"z\0";
pub const MDB_RPAGE_CACHE: ::libc::c_uint = 1;
pub const MDB_SIZE_MAX: u64 = 18446744073709551615;
pub const MDB_VERSION_MAJOR: ::libc::c_uint = 0;
pub const MDB_VERSION_MINOR: ::libc::c_uint = 9;
pub const MDB_VERSION_PATCH: ::libc::c_uint = 90;
pub const MDB_VERSION_DATE: &[u8; 12usize] = b"May 1, 2017\0";
pub const MDB_FIXEDMAP: ::libc::c_uint = 1;
pub const MDB_ENCRYPT: ::libc::c_uint = 8192;
pub const MDB_NOSUBDIR: ::libc::c_uint = 16384;
pub const MDB_NOSYNC: ::libc::c_uint = 65536;
pub const MDB_RDONLY: ::libc::c_uint = 131072;
pub const MDB_NOMETASYNC: ::libc::c_uint = 262144;
pub const MDB_WRITEMAP: ::libc::c_uint = 524288;
pub const MDB_MAPASYNC: ::libc::c_uint = 1048576;
pub const MDB_NOTLS: ::libc::c_uint = 2097152;
pub const MDB_NOLOCK: ::libc::c_uint = 4194304;
pub const MDB_NORDAHEAD: ::libc::c_uint = 8388608;
pub const MDB_NOMEMINIT: ::libc::c_uint = 16777216;
pub const MDB_PREVSNAPSHOT: ::libc::c_uint = 33554432;
pub const MDB_REMAP_CHUNKS: ::libc::c_uint = 67108864;
pub const MDB_REVERSEKEY: ::libc::c_uint = 2;
pub const MDB_DUPSORT: ::libc::c_uint = 4;
pub const MDB_INTEGERKEY: ::libc::c_uint = 8;
pub const MDB_DUPFIXED: ::libc::c_uint = 16;
pub const MDB_INTEGERDUP: ::libc::c_uint = 32;
pub const MDB_REVERSEDUP: ::libc::c_uint = 64;
pub const MDB_CREATE: ::libc::c_uint = 262144;
pub const MDB_NOOVERWRITE: ::libc::c_uint = 16;
pub const MDB_NODUPDATA: ::libc::c_uint = 32;
pub const MDB_CURRENT: ::libc::c_uint = 64;
pub const MDB_RESERVE: ::libc::c_uint = 65536;
pub const MDB_APPEND: ::libc::c_uint = 131072;
pub const MDB_APPENDDUP: ::libc::c_uint = 262144;
pub const MDB_MULTIPLE: ::libc::c_uint = 524288;
pub const MDB_CP_COMPACT: ::libc::c_uint = 1;
pub const MDB_SUCCESS: ::libc::c_int = 0;
pub const MDB_KEYEXIST: ::libc::c_int = -30799;
pub const MDB_NOTFOUND: ::libc::c_int = -30798;
pub const MDB_PAGE_NOTFOUND: ::libc::c_int = -30797;
pub const MDB_CORRUPTED: ::libc::c_int = -30796;
pub const MDB_PANIC: ::libc::c_int = -30795;
pub const MDB_VERSION_MISMATCH: ::libc::c_int = -30794;
pub const MDB_INVALID: ::libc::c_int = -30793;
pub const MDB_MAP_FULL: ::libc::c_int = -30792;
pub const MDB_DBS_FULL: ::libc::c_int = -30791;
pub const MDB_READERS_FULL: ::libc::c_int = -30790;
pub const MDB_TLS_FULL: ::libc::c_int = -30789;
pub const MDB_TXN_FULL: ::libc::c_int = -30788;
pub const MDB_CURSOR_FULL: ::libc::c_int = -30787;
pub const MDB_PAGE_FULL: ::libc::c_int = -30786;
pub const MDB_MAP_RESIZED: ::libc::c_int = -30785;
pub const MDB_INCOMPATIBLE: ::libc::c_int = -30784;
pub const MDB_BAD_RSLOT: ::libc::c_int = -30783;
pub const MDB_BAD_TXN: ::libc::c_int = -30782;
pub const MDB_BAD_VALSIZE: ::libc::c_int = -30781;
pub const MDB_BAD_DBI: ::libc::c_int = -30780;
pub const MDB_PROBLEM: ::libc::c_int = -30779;
pub const MDB_BAD_CHECKSUM: ::libc::c_int = -30778;
pub const MDB_CRYPTO_FAIL: ::libc::c_int = -30777;
pub const MDB_ENV_ENCRYPTION: ::libc::c_int = -30776;
pub const MDB_LAST_ERRCODE: ::libc::c_int = -30776;
#[doc = "Unsigned type used for mapsize, entry counts and page/transaction IDs.\nIt is normally size_t, hence the name. Defining MDB_VL32 makes it\nuint64_t, but do not try this unless you know what you are doing.\n\n"]
pub type mdb_size_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_env {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_txn {
    _unused: [u8; 0],
}
#[doc = "A handle for an individual database in the DB environment.\n\n"]
pub type MDB_dbi = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_cursor {
    _unused: [u8; 0],
}
#[doc = "Generic structure used for passing keys and data in and out\n\nof the database.\nValues returned from the database are valid only until a subsequent\nupdate operation, or the end of the transaction. Do not modify or\nfree them, they commonly point into the database itself.\nKey sizes must be between 1 and #mdb_env_get_maxkeysize() inclusive.\nThe same applies to data sizes in databases with the #MDB_DUPSORT flag.\nOther data items can in theory be from 0 to 0xffffffff bytes long.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_val {
    #[doc = "size of the data item\n\n"]
    pub mv_size: usize,
    #[doc = "address of the data item\n\n"]
    pub mv_data: *mut ::libc::c_void,
}
#[doc = "A callback function used to compare two keys in a database\n\n"]
pub type MDB_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(a: *const MDB_val, b: *const MDB_val) -> ::libc::c_int,
>;
#[doc = "A callback function used to relocate a position-dependent data item\n\nin a fixed-address database.\nThe \\b newptr gives the item's desired address in\nthe memory map, and \\b oldptr gives its previous address. The item's actual\ndata resides at the address in \\b item. This callback is expected to walk\nthrough the fields of the record in \\b item and modify any\nvalues based at the \\b oldptr address to be relative to the \\b newptr address.\n\n# Arguments\n\n* `item` - The item that is to be relocated. [Direction: Out]\n* `oldptr` - The previous address. [Direction: In]\n* `newptr` - The new address to relocate to. [Direction: In]\n* `relctx` - An application-provided context, set by #mdb_set_relctx(). [Direction: In]\n\n# To Do\n\n* This feature is currently unimplemented.\n"]
pub type MDB_rel_func = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut MDB_val,
        oldptr: *mut ::libc::c_void,
        newptr: *mut ::libc::c_void,
        relctx: *mut ::libc::c_void,
    ),
>;
#[doc = "A callback function used to encrypt/decrypt pages in the env.\n\nEncrypt or decrypt the data in src and store the result in dst using the\nprovided key. The result must be the same number of bytes as the input.\nkey[1] is the initialization vector, and key[2] is the authentication\ndata, if any.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `src` - The input data to be transformed. [Direction: In]\n* `dst` - Storage for the result. [Direction: In, Out]\n* `key` - An array of three values: key[0] is the encryption key, [Direction: In]\n* `encdec` - 1 to encrypt, 0 to decrypt. [Direction: In]\n\n"]
pub type MDB_enc_func = ::std::option::Option<
    unsafe extern "C" fn(
        src: *const MDB_val,
        dst: *mut MDB_val,
        key: *const MDB_val,
        encdec: ::libc::c_int,
    ) -> ::libc::c_int,
>;
#[doc = "A callback function used to checksum pages in the env.\n\nCompute the checksum of the data in src and store the result in dst,\nAn optional key may be used with keyed hash algorithms.\nparameter will be NULL if there is no key.\n\n# Arguments\n\n* `src` - The input data to be transformed. [Direction: In]\n* `dst` - Storage for the result. [Direction: In, Out]\n* `key` - An encryption key, if encryption was configured. This [Direction: In]\n\n"]
pub type MDB_sum_func = ::std::option::Option<
    unsafe extern "C" fn(src: *const MDB_val, dst: *mut MDB_val, key: *const MDB_val),
>;
#[doc = "Position at first key/data item\n\n"]
pub const MDB_FIRST: MDB_cursor_op = 0;
#[doc = "Position at first data item of current key.\nOnly for #MDB_DUPSORT\n\n"]
pub const MDB_FIRST_DUP: MDB_cursor_op = 1;
#[doc = "Position at key/data pair. Only for #MDB_DUPSORT\n\n"]
pub const MDB_GET_BOTH: MDB_cursor_op = 2;
#[doc = "position at key, nearest data. Only for #MDB_DUPSORT\n\n"]
pub const MDB_GET_BOTH_RANGE: MDB_cursor_op = 3;
#[doc = "Return key/data at current cursor position\n\n"]
pub const MDB_GET_CURRENT: MDB_cursor_op = 4;
#[doc = "Return up to a page of duplicate data items\nfrom current cursor position. Move cursor to prepare\nfor #MDB_NEXT_MULTIPLE. Only for #MDB_DUPFIXED\n\n"]
pub const MDB_GET_MULTIPLE: MDB_cursor_op = 5;
#[doc = "Position at last key/data item\n\n"]
pub const MDB_LAST: MDB_cursor_op = 6;
#[doc = "Position at last data item of current key.\nOnly for #MDB_DUPSORT\n\n"]
pub const MDB_LAST_DUP: MDB_cursor_op = 7;
#[doc = "Position at next data item\n\n"]
pub const MDB_NEXT: MDB_cursor_op = 8;
#[doc = "Position at next data item of current key.\nOnly for #MDB_DUPSORT\n\n"]
pub const MDB_NEXT_DUP: MDB_cursor_op = 9;
#[doc = "Return up to a page of duplicate data items\nfrom next cursor position. Move cursor to prepare\nfor #MDB_NEXT_MULTIPLE. Only for #MDB_DUPFIXED\n\n"]
pub const MDB_NEXT_MULTIPLE: MDB_cursor_op = 10;
#[doc = "Position at first data item of next key\n\n"]
pub const MDB_NEXT_NODUP: MDB_cursor_op = 11;
#[doc = "Position at previous data item\n\n"]
pub const MDB_PREV: MDB_cursor_op = 12;
#[doc = "Position at previous data item of current key.\nOnly for #MDB_DUPSORT\n\n"]
pub const MDB_PREV_DUP: MDB_cursor_op = 13;
#[doc = "Position at last data item of previous key\n\n"]
pub const MDB_PREV_NODUP: MDB_cursor_op = 14;
#[doc = "Position at specified key\n\n"]
pub const MDB_SET: MDB_cursor_op = 15;
#[doc = "Position at specified key, return key + data\n\n"]
pub const MDB_SET_KEY: MDB_cursor_op = 16;
#[doc = "Position at first key greater than or equal to specified key.\n\n"]
pub const MDB_SET_RANGE: MDB_cursor_op = 17;
#[doc = "Position at previous page and return up to\na page of duplicate data items. Only for #MDB_DUPFIXED\n\n"]
pub const MDB_PREV_MULTIPLE: MDB_cursor_op = 18;
#[doc = "Cursor Get operations.\n\nThis is the set of all operations for retrieving data\nusing a cursor.\n\n"]
pub type MDB_cursor_op = ::libc::c_uint;
#[doc = "Statistics for a database in the environment\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_stat {
    #[doc = "Size of a database page.\nThis is currently the same for all databases.\n\n"]
    pub ms_psize: ::libc::c_uint,
    #[doc = "Depth (height) of the B-tree\n\n"]
    pub ms_depth: ::libc::c_uint,
    #[doc = "Number of internal (non-leaf) pages\n\n"]
    pub ms_branch_pages: mdb_size_t,
    #[doc = "Number of leaf pages\n\n"]
    pub ms_leaf_pages: mdb_size_t,
    #[doc = "Number of overflow pages\n\n"]
    pub ms_overflow_pages: mdb_size_t,
    #[doc = "Number of data items\n\n"]
    pub ms_entries: mdb_size_t,
}
#[doc = "Information about the environment\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_envinfo {
    #[doc = "Address of map, if fixed\n\n"]
    pub me_mapaddr: *mut ::libc::c_void,
    #[doc = "Size of the data memory map\n\n"]
    pub me_mapsize: mdb_size_t,
    #[doc = "ID of the last used page\n\n"]
    pub me_last_pgno: mdb_size_t,
    #[doc = "ID of the last committed transaction\n\n"]
    pub me_last_txnid: mdb_size_t,
    #[doc = "max reader slots in the environment\n\n"]
    pub me_maxreaders: ::libc::c_uint,
    #[doc = "max reader slots used in the environment\n\n"]
    pub me_numreaders: ::libc::c_uint,
}
extern "C" {
    #[doc = "Return the LMDB library version information.\n\n# Arguments\n\n* `major` - if non-NULL, the library major version number is copied here [Direction: In, Out]\n* `minor` - if non-NULL, the library minor version number is copied here [Direction: In, Out]\n* `patch` - if non-NULL, the library patch version number is copied here [Direction: In, Out]\n\n# Return values\n* \"version string\" The library version as a string\n\n"]
    pub fn mdb_version(
        major: *mut ::libc::c_int,
        minor: *mut ::libc::c_int,
        patch: *mut ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    #[doc = "Return a string describing a given error code.\n\nThis function is a superset of the ANSI C X3.159-1989 (ANSI C) strerror(3)\nfunction. If the error code is greater than or equal to 0, then the string\nreturned by the system function strerror(3) is returned. If the error code\nis less than 0, an error string corresponding to the LMDB library error is\nreturned. See [`errors`] for a list of LMDB-specific error codes.\n\n# Arguments\n\n* `err` - The error code [Direction: In]\n\n# Return values\n* \"error message\" The description of the error\n\n"]
    pub fn mdb_strerror(err: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    #[doc = "Create an LMDB environment handle.\n\nThis function allocates memory for a #MDB_env structure. To release\nthe allocated memory and discard the handle, call #mdb_env_close().\nBefore the handle may be used, it must be opened using #mdb_env_open().\nVarious other options may also need to be set before opening the handle,\ne.g. #mdb_env_set_mapsize(), #mdb_env_set_maxreaders(), #mdb_env_set_maxdbs(),\ndepending on usage requirements.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `env` - The address where the new handle will be stored [Direction: In, Out]\n\n"]
    pub fn mdb_env_create(env: *mut *mut MDB_env) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Open an environment handle.\n\nIf this function fails, #mdb_env_close() must be called to discard the #MDB_env handle.\ndirectory must already exist and be writable.\nmust be set to 0 or by bitwise OR'ing together one or more of the\nvalues described here.\nFlags set by mdb_env_set_flags() are also used.\n<ul>\n<li>#MDB_FIXEDMAP\nuse a fixed address for the mmap region. This flag must be specified\nwhen creating the environment, and is stored persistently in the environment.\nIf successful, the memory map will always reside at the same virtual address\nand pointers used to reference data items in the database will be constant\nacross multiple invocations. This option may not always work, depending on\nhow the operating system has allocated memory to shared libraries and other uses.\nThe feature is highly experimental.\n<li>#MDB_NOSUBDIR\nBy default, LMDB creates its environment in a directory whose\npathname is given in \\b path, and creates its data and lock files\nunder that directory. With this option, \\b path is used as-is for\nthe database main data file. The database lock file is the \\b path\nwith \"-lock\" appended.\n<li>#MDB_RDONLY\nOpen the environment in read-only mode. No write operations will be\nallowed. LMDB will still modify the lock file - except on read-only\nfilesystems, where LMDB does not use locks.\n<li>#MDB_WRITEMAP\nUse a writeable memory map unless MDB_RDONLY is set. This uses\nfewer mallocs but loses protection from application bugs\nlike wild pointer writes and other bad updates into the database.\nThis may be slightly faster for DBs that fit entirely in RAM, but\nis slower for DBs larger than RAM.\nIncompatible with nested transactions.\nDo not mix processes with and without MDB_WRITEMAP on the same\nenvironment. This can defeat durability (#mdb_env_sync etc).\n<li>#MDB_NOMETASYNC\nFlush system buffers to disk only once per transaction, omit the\nmetadata flush. Defer that until the system flushes files to disk,\nor next non-MDB_RDONLY commit or #mdb_env_sync(). This optimization\nmaintains database integrity, but a system crash may undo the last\ncommitted transaction. I.e. it preserves the ACI (atomicity,\nconsistency, isolation) but not D (durability) database property.\nThis flag may be changed at any time using #mdb_env_set_flags().\n<li>#MDB_NOSYNC\nDon't flush system buffers to disk when committing a transaction.\nThis optimization means a system crash can corrupt the database or\nlose the last transactions if buffers are not yet flushed to disk.\nThe risk is governed by how often the system flushes dirty buffers\nto disk and how often #mdb_env_sync() is called. However, if the\nfilesystem preserves write order and the #MDB_WRITEMAP flag is not\nused, transactions exhibit ACI (atomicity, consistency, isolation)\nproperties and only lose D (durability). I.e. database integrity\nis maintained, but a system crash may undo the final transactions.\nNote that (#MDB_NOSYNC | #MDB_WRITEMAP) leaves the system with no\nhint for when to write transactions to disk, unless #mdb_env_sync()\nis called. (#MDB_MAPASYNC | #MDB_WRITEMAP) may be preferable.\nThis flag may be changed at any time using #mdb_env_set_flags().\n<li>#MDB_MAPASYNC\nWhen using #MDB_WRITEMAP, use asynchronous flushes to disk.\nAs with #MDB_NOSYNC, a system crash can then corrupt the\ndatabase or lose the last transactions. Calling #mdb_env_sync()\nensures on-disk database integrity until next commit.\nThis flag may be changed at any time using #mdb_env_set_flags().\n<li>#MDB_NOTLS\nDon't use Thread-Local Storage. Tie reader locktable slots to\n#MDB_txn objects instead of to threads. I.e. #mdb_txn_reset() keeps\nthe slot reserved for the #MDB_txn object. A thread may use parallel\nread-only transactions. A read-only transaction may span threads if\nthe user synchronizes its use. Applications that multiplex many\nuser threads over individual OS threads need this option. Such an\napplication must also serialize the write transactions in an OS\nthread, since LMDB's write locking is unaware of the user threads.\n<li>#MDB_NOLOCK\nDon't do any locking. If concurrent access is anticipated, the\ncaller must manage all concurrency itself. For proper operation\nthe caller must enforce single-writer semantics, and must ensure\nthat no readers are using old transactions while a writer is\nactive. The simplest approach is to use an exclusive lock so that\nno readers may be active at all when a writer begins.\n<li>#MDB_NORDAHEAD\nTurn off readahead. Most operating systems perform readahead on\nread requests by default. This option turns it off if the OS\nsupports it. Turning it off may help random read performance\nwhen the DB is larger than RAM and system RAM is full.\nThe option is not implemented on Windows.\n<li>#MDB_NOMEMINIT\nDon't initialize malloc'd memory before writing to unused spaces\nin the data file. By default, memory for pages written to the data\nfile is obtained using malloc. While these pages may be reused in\nsubsequent transactions, freshly malloc'd pages will be initialized\nto zeroes before use. This avoids persisting leftover data from other\ncode (that used the heap and subsequently freed the memory) into the\ndata file. Note that many other system libraries may allocate\nand free memory from the heap for arbitrary uses. E.g., stdio may\nuse the heap for file I/O buffers. This initialization step has a\nmodest performance cost so some applications may want to disable\nit using this flag. This option can be a problem for applications\nwhich handle sensitive data like passwords, and it makes memory\ncheckers like Valgrind noisy. This flag is not needed with #MDB_WRITEMAP,\nwhich writes directly to the mmap instead of using malloc for pages. The\ninitialization is also skipped if #MDB_RESERVE is used; the\ncaller is expected to overwrite all of the memory that was\nreserved in that case.\nThis flag may be changed at any time using #mdb_env_set_flags().\n<li>#MDB_PREVSNAPSHOT\nOpen the environment with the previous snapshot rather than the latest\none. This loses the latest transaction, but may help work around some\ntypes of corruption. If opened with write access, this must be the\nonly process using the environment. This flag is automatically reset\nafter a write transaction is successfully committed.\n</ul>\nThis parameter is ignored on Windows.\nerrors are:\n<ul>\n<li>#MDB_VERSION_MISMATCH - the version of the LMDB library doesn't match the\nversion that created the database environment.\n<li>#MDB_INVALID - the environment file headers are corrupted.\n<li>ENOENT - the directory specified by the path parameter doesn't exist.\n<li>EACCES - the user didn't have permission to access the environment files.\n<li>EAGAIN - the environment was locked by another process.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `path` - The directory in which the database files reside. This [Direction: In]\n* `flags` - Special options for this environment. This parameter [Direction: In]\n* `mode` - The UNIX permissions to set on created files and semaphores. [Direction: In]\n\n"]
    pub fn mdb_env_open(
        env: *mut MDB_env,
        path: *const ::libc::c_char,
        flags: ::libc::c_uint,
        mode: mdb_mode_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Copy an LMDB environment to the specified path.\n\nThis function may be used to make a backup of an existing environment.\nNo lockfile is created, since it gets recreated at need.\nparallel with write transactions, because it employs a read-only\ntransaction. See long-lived transactions under [`caveats_sec`]\nmust have already been opened successfully.\ndirectory must already exist and be writable but must otherwise be\nempty.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create(). It [Direction: In]\n* `path` - The directory in which the copy will reside. This [Direction: In]\n\n# Notes\n\n* This call can trigger significant file size growth if run in\n\n"]
    pub fn mdb_env_copy(env: *mut MDB_env, path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Copy an LMDB environment to the specified file descriptor.\n\nThis function may be used to make a backup of an existing environment.\nNo lockfile is created, since it gets recreated at need.\nparallel with write transactions, because it employs a read-only\ntransaction. See long-lived transactions under [`caveats_sec`]\nmust have already been opened successfully.\nhave already been opened for Write access.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create(). It [Direction: In]\n* `fd` - The filedescriptor to write the copy to. It must [Direction: In]\n\n# Notes\n\n* This call can trigger significant file size growth if run in\n\n"]
    pub fn mdb_env_copyfd(env: *mut MDB_env, fd: mdb_filehandle_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Copy an LMDB environment to the specified path, with options.\n\nThis function may be used to make a backup of an existing environment.\nNo lockfile is created, since it gets recreated at need.\nparallel with write transactions, because it employs a read-only\ntransaction. See long-lived transactions under [`caveats_sec`]\nmust have already been opened successfully.\ndirectory must already exist and be writable but must otherwise be\nempty.\nmust be set to 0 or by bitwise OR'ing together one or more of the\nvalues described here.\n<ul>\n<li>#MDB_CP_COMPACT - Perform compaction while copying: omit free\npages and sequentially renumber all pages in output. This option\nconsumes more CPU and runs more slowly than the default.\nCurrently it fails if the environment has suffered a page leak.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create(). It [Direction: In]\n* `path` - The directory in which the copy will reside. This [Direction: In]\n* `flags` - Special options for this operation. This parameter [Direction: In]\n\n# Notes\n\n* This call can trigger significant file size growth if run in\n\n"]
    pub fn mdb_env_copy2(
        env: *mut MDB_env,
        path: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Copy an LMDB environment to the specified file descriptor,\n\nwith options.\nThis function may be used to make a backup of an existing environment.\nNo lockfile is created, since it gets recreated at need. See\n#mdb_env_copy2() for further details.\nparallel with write transactions, because it employs a read-only\ntransaction. See long-lived transactions under [`caveats_sec`]\nmust have already been opened successfully.\nhave already been opened for Write access.\nSee #mdb_env_copy2() for options.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create(). It [Direction: In]\n* `fd` - The filedescriptor to write the copy to. It must [Direction: In]\n* `flags` - Special options for this operation. [Direction: In]\n\n# Notes\n\n* This call can trigger significant file size growth if run in\n\n"]
    pub fn mdb_env_copyfd2(
        env: *mut MDB_env,
        fd: mdb_filehandle_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Return statistics about the LMDB environment.\n\nwhere the statistics will be copied\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `stat` - The address of an #MDB_stat structure [Direction: In, Out]\n\n"]
    pub fn mdb_env_stat(env: *mut MDB_env, stat: *mut MDB_stat) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Return information about the LMDB environment.\n\nwhere the information will be copied\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `stat` - The address of an #MDB_envinfo structure [Direction: In, Out]\n\n"]
    pub fn mdb_env_info(env: *mut MDB_env, stat: *mut MDB_envinfo) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Flush the data buffers to disk.\n\nData is always written to disk when #mdb_txn_commit() is called,\nbut the operating system may keep it buffered. LMDB always flushes\nthe OS buffers upon commit as well, unless the environment was\nopened with #MDB_NOSYNC or in part #MDB_NOMETASYNC. This call is\nnot valid if the environment was opened with #MDB_RDONLY.\nif the environment has the #MDB_NOSYNC flag set the flushes\nwill be omitted, and with #MDB_MAPASYNC they will be asynchronous.\nerrors are:\n<ul>\n<li>EACCES - the environment is read-only.\n<li>EINVAL - an invalid parameter was specified.\n<li>EIO - an error occurred during synchronization.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `force` - If non-zero, force a synchronous flush. Otherwise [Direction: In]\n\n"]
    pub fn mdb_env_sync(env: *mut MDB_env, force: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Close the environment and release the memory map.\n\nOnly a single thread may call this function. All transactions, databases,\nand cursors must already be closed before calling this function. Attempts to\nuse any such handles after calling this function will cause a SIGSEGV.\nThe environment handle will be freed and must not be used again after this call.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n\n"]
    pub fn mdb_env_close(env: *mut MDB_env);
}
extern "C" {
    #[doc = "Set environment flags.\n\nThis may be used to set some flags in addition to those from\n#mdb_env_open(), or to unset these flags. If several threads\nchange the flags at the same time, the result is undefined.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `flags` - The flags to change, bitwise OR'ed together [Direction: In]\n* `onoff` - A non-zero value sets the flags, zero clears them. [Direction: In]\n\n"]
    pub fn mdb_env_set_flags(
        env: *mut MDB_env,
        flags: ::libc::c_uint,
        onoff: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Get environment flags.\n\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `flags` - The address of an integer to store the flags [Direction: In, Out]\n\n"]
    pub fn mdb_env_get_flags(env: *mut MDB_env, flags: *mut ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Return the path that was used in #mdb_env_open().\n\nis the actual string in the environment, not a copy. It should not be\naltered in any way.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `path` - Address of a string pointer to contain the path. This [Direction: In, Out]\n\n"]
    pub fn mdb_env_get_path(env: *mut MDB_env, path: *mut *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Return the filedescriptor for the given environment.\n\nThis function may be called after fork(), so the descriptor can be\nclosed before exec*(). Other LMDB file descriptors have FD_CLOEXEC.\n(Until LMDB 0.9.18, only the lockfile had that.)\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `fd` - Address of a mdb_filehandle_t to contain the descriptor. [Direction: In, Out]\n\n"]
    pub fn mdb_env_get_fd(env: *mut MDB_env, fd: *mut mdb_filehandle_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set the size of the memory map to use for this environment.\n\nThe size should be a multiple of the OS page size. The default is\n10485760 bytes. The size of the memory map is also the maximum size\nof the database. The value should be chosen as large as possible,\nto accommodate future growth of the database.\nThis function should be called after #mdb_env_create() and before #mdb_env_open().\nIt may be called at later times if no transactions are active in\nthis process. Note that the library does not check for this condition,\nthe caller must ensure it explicitly.\nThe new size takes effect immediately for the current process but\nwill not be persisted to any others until a write transaction has been\ncommitted by the current process. Also, only mapsize increases are\npersisted into the environment.\nIf the mapsize is increased by another process, and data has grown\nbeyond the range of the current mapsize, #mdb_txn_begin() will\nreturn #MDB_MAP_RESIZED. This function may be called with a size\nof zero to adopt the new size.\nAny attempt to set a size smaller than the space already consumed\nby the environment will be silently changed to the current size of the used space.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified, or the environment has\nan active write transaction.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `size` - The size in bytes [Direction: In]\n\n"]
    pub fn mdb_env_set_mapsize(env: *mut MDB_env, size: mdb_size_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set the size of DB pages in bytes.\n\nThe size defaults to the OS page size. Smaller or larger values may be\ndesired depending on the size of keys and values being used. Also, an\nexplicit size may need to be set when using filesystems like ZFS which\ndon't use the OS page size.\n\n"]
    pub fn mdb_env_set_pagesize(env: *mut MDB_env, size: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set the maximum number of threads/reader slots for the environment.\n\nThis defines the number of slots in the lock table that is used to track readers in the\nthe environment. The default is 126.\nStarting a read-only transaction normally ties a lock table slot to the\ncurrent thread until the environment closes or the thread exits. If\nMDB_NOTLS is in use, #mdb_txn_begin() instead ties the slot to the\nMDB_txn object until it or the #MDB_env object is destroyed.\nThis function may only be called after #mdb_env_create() and before #mdb_env_open().\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified, or the environment is already open.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `readers` - The maximum number of reader lock table slots [Direction: In]\n\n"]
    pub fn mdb_env_set_maxreaders(env: *mut MDB_env, readers: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Get the maximum number of threads/reader slots for the environment.\n\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `readers` - Address of an integer to store the number of readers [Direction: In, Out]\n\n"]
    pub fn mdb_env_get_maxreaders(env: *mut MDB_env, readers: *mut ::libc::c_uint)
        -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set the maximum number of named databases for the environment.\n\nThis function is only needed if multiple databases will be used in the\nenvironment. Simpler applications that use the environment as a single\nunnamed database can ignore this option.\nThis function may only be called after #mdb_env_create() and before #mdb_env_open().\nCurrently a moderate number of slots are cheap but a huge number gets\nexpensive: 7-120 words per transaction, and every #mdb_dbi_open()\ndoes a linear search of the opened slots.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified, or the environment is already open.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `dbs` - The maximum number of databases [Direction: In]\n\n"]
    pub fn mdb_env_set_maxdbs(env: *mut MDB_env, dbs: MDB_dbi) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Get the maximum size of keys and #MDB_DUPSORT data we can write.\n\nDepends on the compile-time constant #MDB_MAXKEYSIZE. Default 511.\nSee [`MDB_val`]\n\nReturns:\n\n* The maximum size of a key we can write\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n\n"]
    pub fn mdb_env_get_maxkeysize(env: *mut MDB_env) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set application information associated with the #MDB_env.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `ctx` - An arbitrary pointer for whatever the application needs. [Direction: In]\n\n"]
    pub fn mdb_env_set_userctx(env: *mut MDB_env, ctx: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Get the application information associated with the #MDB_env.\n\nReturns:\n\n* The pointer set by #mdb_env_set_userctx().\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n\n"]
    pub fn mdb_env_get_userctx(env: *mut MDB_env) -> *mut ::libc::c_void;
}
#[doc = "A callback function for most LMDB assert() failures,\n\ncalled before printing the message and aborting.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create(). [Direction: In]\n* `msg` - The assertion message, not including newline. [Direction: In]\n\n"]
pub type MDB_assert_func =
    ::std::option::Option<unsafe extern "C" fn(env: *mut MDB_env, msg: *const ::libc::c_char)>;
extern "C" {
    #[doc = "Set or reset the assert() callback of the environment.\nDisabled if liblmdb is built with NDEBUG.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create(). [Direction: In]\n* `func` - An #MDB_assert_func function, or 0. [Direction: In]\n\n# Notes\n\n* This hack should become obsolete as lmdb's error handling matures.\n\n"]
    pub fn mdb_env_set_assert(env: *mut MDB_env, func: MDB_assert_func) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set encryption on an environment.\n\nThis must be called before #mdb_env_open().\nIt implicitly sets #MDB_REMAP_CHUNKS on the env.\nSet this to zero for unauthenticated encryption mechanisms.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create(). [Direction: In]\n* `func` - An #MDB_enc_func function. [Direction: In]\n* `key` - The encryption key. [Direction: In]\n* `size` - The size of authentication data in bytes, if any. [Direction: In]\n\n"]
    pub fn mdb_env_set_encrypt(
        env: *mut MDB_env,
        func: MDB_enc_func,
        key: *const MDB_val,
        size: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set checksums on an environment.\n\nThis must be called before #mdb_env_open().\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create(). [Direction: In]\n* `func` - An #MDB_sum_func function. [Direction: In]\n* `size` - The size of computed checksum values, in bytes. [Direction: In]\n\n"]
    pub fn mdb_env_set_checksum(
        env: *mut MDB_env,
        func: MDB_sum_func,
        size: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Create a transaction for use with the environment.\n\nThe transaction handle may be discarded using #mdb_txn_abort() or #mdb_txn_commit().\nthread, and a thread may only have a single transaction at a time.\nIf #MDB_NOTLS is in use, this does not apply to read-only transactions.\nwill be a nested transaction, with the transaction indicated by \\b parent\nas its parent. Transactions may be nested to any level. A parent\ntransaction and its cursors may not issue any other operations than\nmdb_txn_commit and mdb_txn_abort while it has active child transactions.\nmust be set to 0 or by bitwise OR'ing together one or more of the\nvalues described here.\n<ul>\n<li>#MDB_RDONLY\nThis transaction will not perform any write operations.\n<li>#MDB_NOSYNC\nDon't flush system buffers to disk when committing this transaction.\n<li>#MDB_NOMETASYNC\nFlush system buffers but omit metadata flush when committing this transaction.\n</ul>\nerrors are:\n<ul>\n<li>#MDB_PANIC - a fatal error occurred earlier and the environment\nmust be shut down.\n<li>#MDB_MAP_RESIZED - another process wrote data beyond this MDB_env's\nmapsize and this environment's map must be resized as well.\nSee #mdb_env_set_mapsize().\n<li>#MDB_READERS_FULL - a read-only transaction was requested and\nthe reader lock table is full. See #mdb_env_set_maxreaders().\n<li>ENOMEM - out of memory.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `parent` - If this parameter is non-NULL, the new transaction [Direction: In]\n* `flags` - Special options for this transaction. This parameter [Direction: In]\n* `txn` - Address where the new #MDB_txn handle will be stored [Direction: In, Out]\n\n# Notes\n\n* A transaction and its cursors must only be used by a single\n* Cursors may not span transactions.\n\n"]
    pub fn mdb_txn_begin(
        env: *mut MDB_env,
        parent: *mut MDB_txn,
        flags: ::libc::c_uint,
        txn: *mut *mut MDB_txn,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Returns the transaction's #MDB_env\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n\n"]
    pub fn mdb_txn_env(txn: *mut MDB_txn) -> *mut MDB_env;
}
extern "C" {
    #[doc = "Return the transaction's ID.\n\nThis returns the identifier associated with this transaction. For a\nread-only transaction, this corresponds to the snapshot being read;\nconcurrent readers will frequently have the same transaction ID.\n\nReturns:\n\n* A transaction ID, valid if input is an active transaction.\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n\n"]
    pub fn mdb_txn_id(txn: *mut MDB_txn) -> mdb_size_t;
}
extern "C" {
    #[doc = "Commit all the operations of a transaction into the database.\n\nThe transaction handle is freed. It and its cursors must not be used\nagain after this call, except with #mdb_cursor_renew().\nOnly write-transactions free cursors.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n<li>ENOSPC - no more disk space.\n<li>EIO - a low-level I/O error occurred while writing.\n<li>ENOMEM - out of memory.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n\n# Notes\n\n* Earlier documentation incorrectly said all cursors would be freed.\n\n"]
    pub fn mdb_txn_commit(txn: *mut MDB_txn) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Abandon all the operations of the transaction instead of saving them.\n\nThe transaction handle is freed. It and its cursors must not be used\nagain after this call, except with #mdb_cursor_renew().\nOnly write-transactions free cursors.\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n\n# Notes\n\n* Earlier documentation incorrectly said all cursors would be freed.\n\n"]
    pub fn mdb_txn_abort(txn: *mut MDB_txn);
}
extern "C" {
    #[doc = "Reset a read-only transaction.\n\nAbort the transaction like #mdb_txn_abort(), but keep the transaction\nhandle. #mdb_txn_renew() may reuse the handle. This saves allocation\noverhead if the process will start a new read-only transaction soon,\nand also locking overhead if #MDB_NOTLS is in use. The reader table\nlock is released, but the table slot stays tied to its thread or\n#MDB_txn. Use mdb_txn_abort() to discard a reset handle, and to free\nits lock table slot if MDB_NOTLS is in use.\nCursors opened within the transaction must not be used\nagain after this call, except with #mdb_cursor_renew().\nReader locks generally don't interfere with writers, but they keep old\nversions of database pages allocated. Thus they prevent the old pages\nfrom being reused when writers commit new data, and so under heavy load\nthe database size may grow much more rapidly than otherwise.\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n\n"]
    pub fn mdb_txn_reset(txn: *mut MDB_txn);
}
extern "C" {
    #[doc = "Renew a read-only transaction.\n\nThis acquires a new reader lock for a transaction handle that had been\nreleased by #mdb_txn_reset(). It must be called before a reset transaction\nmay be used again.\nerrors are:\n<ul>\n<li>#MDB_PANIC - a fatal error occurred earlier and the environment\nmust be shut down.\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n\n"]
    pub fn mdb_txn_renew(txn: *mut MDB_txn) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Open a database in the environment.\n\nA database handle denotes the name and parameters of a database,\nindependently of whether such a database exists.\nThe database handle may be discarded by calling #mdb_dbi_close().\nThe old database handle is returned if the database was already open.\nThe handle may only be closed once.\nThe database handle will be private to the current transaction until\nthe transaction is successfully committed. If the transaction is\naborted the handle will be closed automatically.\nAfter a successful commit the handle will reside in the shared\nenvironment, and may be used by other transactions.\nThis function must not be called from multiple concurrent\ntransactions in the same process. A transaction that uses\nthis function must finish (either commit or abort) before\nany other transaction in the process may use this function.\nTo use named databases (with name != NULL), #mdb_env_set_maxdbs()\nmust be called before opening the environment. Database names are\nkeys in the unnamed database, and may be read but not written.\nIn LMDB 0.9 the NUL terminator was omitted.\ndatabase is needed in the environment, this value may be NULL.\nmust be set to 0 or by bitwise OR'ing together one or more of the\nvalues described here.\n<ul>\n<li>#MDB_REVERSEKEY\nKeys are strings to be compared in reverse order, from the end\nof the strings to the beginning. By default, Keys are treated as strings and\ncompared from beginning to end.\n<li>#MDB_DUPSORT\nDuplicate keys may be used in the database. (Or, from another perspective,\nkeys may have multiple data items, stored in sorted order.) By default\nkeys must be unique and may have only a single data item.\n<li>#MDB_INTEGERKEY\nKeys are binary integers in native byte order, either unsigned int\nor #mdb_size_t, and will be sorted as such.\n(lmdb expects 32-bit int <= size_t <= 32/64-bit mdb_size_t.)\nThe keys must all be of the same size.\n<li>#MDB_DUPFIXED\nThis flag may only be used in combination with #MDB_DUPSORT. This option\ntells the library that the data items for this database are all the same\nsize, which allows further optimizations in storage and retrieval. When\nall data items are the same size, the #MDB_GET_MULTIPLE, #MDB_NEXT_MULTIPLE\nand #MDB_PREV_MULTIPLE cursor operations may be used to retrieve multiple\nitems at once.\n<li>#MDB_INTEGERDUP\nThis option specifies that duplicate data items are binary integers,\nsimilar to #MDB_INTEGERKEY keys.\n<li>#MDB_REVERSEDUP\nThis option specifies that duplicate data items should be compared as\nstrings in reverse order.\n<li>#MDB_CREATE\nCreate the named database if it doesn't exist. This option is not\nallowed in a read-only transaction or a read-only environment.\n</ul>\nerrors are:\n<ul>\n<li>#MDB_NOTFOUND - the specified database doesn't exist in the environment\nand #MDB_CREATE was not specified.\n<li>#MDB_DBS_FULL - too many databases have been opened. See #mdb_env_set_maxdbs().\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `name` - The name of the database to open. If only a single [Direction: In]\n* `flags` - Special options for this database. This parameter [Direction: In]\n* `dbi` - Address where the new #MDB_dbi handle will be stored [Direction: In, Out]\n\n# Notes\n\n* Names are C strings and stored with their NUL terminator included.\n\n"]
    pub fn mdb_dbi_open(
        txn: *mut MDB_txn,
        name: *const ::libc::c_char,
        flags: ::libc::c_uint,
        dbi: *mut MDB_dbi,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Retrieve statistics for a database.\n\nwhere the statistics will be copied\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `stat` - The address of an #MDB_stat structure [Direction: In, Out]\n\n"]
    pub fn mdb_stat(txn: *mut MDB_txn, dbi: MDB_dbi, stat: *mut MDB_stat) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Retrieve the DB flags for a database handle.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `flags` - Address where the flags will be returned. [Direction: In, Out]\n\n"]
    pub fn mdb_dbi_flags(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        flags: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Close a database handle. Normally unnecessary. Use with care:\n\nThis call is not mutex protected. Handles should only be closed by\na single thread, and only if no other threads are going to reference\nthe database handle or one of its cursors any further. Do not close\na handle if an existing transaction has modified its database.\nDoing so can cause misbehavior from database corruption to errors\nlike MDB_BAD_VALSIZE (since the DB name is gone).\nClosing a database handle is not necessary, but lets #mdb_dbi_open()\nreuse the handle value. Usually it's better to set a bigger\n#mdb_env_set_maxdbs(), unless that value would be large.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n\n"]
    pub fn mdb_dbi_close(env: *mut MDB_env, dbi: MDB_dbi);
}
extern "C" {
    #[doc = "Empty or delete+close a database.\n\nSee #mdb_dbi_close() for restrictions about closing the DB handle.\nenvironment and close the DB handle.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success.\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `del` - 0 to empty the DB, 1 to delete it from the [Direction: In]\n\n"]
    pub fn mdb_drop(txn: *mut MDB_txn, dbi: MDB_dbi, del: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set a custom key comparison function for a database.\n\nThe comparison function is called whenever it is necessary to compare a\nkey specified by the application with a key currently stored in the database.\nIf no comparison function is specified, and no special key flags were specified\nwith #mdb_dbi_open(), the keys are compared lexically, with shorter keys collating\nbefore longer keys.\notherwise data corruption may occur. The same comparison function must be used by every\nprogram accessing the database, every time the database is used.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\n**Warning!**\n\n* This function must be called before any data access functions are used,\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `cmp` - A #MDB_cmp_func function [Direction: In]\n\n"]
    pub fn mdb_set_compare(txn: *mut MDB_txn, dbi: MDB_dbi, cmp: MDB_cmp_func) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set a custom data comparison function for a #MDB_DUPSORT database.\n\nThis comparison function is called whenever it is necessary to compare a data\nitem specified by the application with a data item currently stored in the database.\nThis function only takes effect if the database was opened with the #MDB_DUPSORT\nflag.\nIf no comparison function is specified, and no special key flags were specified\nwith #mdb_dbi_open(), the data items are compared lexically, with shorter items collating\nbefore longer items.\notherwise data corruption may occur. The same comparison function must be used by every\nprogram accessing the database, every time the database is used.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\n**Warning!**\n\n* This function must be called before any data access functions are used,\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `cmp` - A #MDB_cmp_func function [Direction: In]\n\n"]
    pub fn mdb_set_dupsort(txn: *mut MDB_txn, dbi: MDB_dbi, cmp: MDB_cmp_func) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set a relocation function for a #MDB_FIXEDMAP database.\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `rel` - A #MDB_rel_func function [Direction: In]\n\n# To Do\n\n* The relocation function is called whenever it is necessary to move the data\nof an item to a different position in the database (e.g. through tree\nbalancing operations, shifts as a result of adds or deletes, etc.). It is\nintended to allow address/position-dependent data items to be stored in\na database in an environment opened with the #MDB_FIXEDMAP option.\nCurrently the relocation feature is unimplemented and setting\nthis function has no effect.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n"]
    pub fn mdb_set_relfunc(txn: *mut MDB_txn, dbi: MDB_dbi, rel: MDB_rel_func) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Set a context pointer for a #MDB_FIXEDMAP database's relocation function.\n\nSee #mdb_set_relfunc and #MDB_rel_func for more details.\nIt will be passed to the callback function set by #mdb_set_relfunc\nas its \\b relctx parameter whenever the callback is invoked.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `ctx` - An arbitrary pointer for whatever the application needs. [Direction: In]\n\n"]
    pub fn mdb_set_relctx(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Get items from a database.\n\nThis function retrieves key/data pairs from the database. The address\nand length of the data associated with the specified \\b key are returned\nin the structure to which \\b data refers.\nIf the database supports duplicate keys (#MDB_DUPSORT) then the\nfirst data item for the key will be returned. Retrieval of other\nitems requires the use of #mdb_cursor_get().\ndatabase. The caller need not dispose of the memory, and may not\nmodify it in any way. For values returned in a read-only transaction\nany modification attempts will cause a SIGSEGV.\nsubsequent update operation, or the end of the transaction.\nerrors are:\n<ul>\n<li>#MDB_NOTFOUND - the key was not in the database.\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `key` - The key to search for in the database [Direction: In]\n* `data` - The data corresponding to the key [Direction: In, Out]\n\n# Notes\n\n* The memory pointed to by the returned values is owned by the\n* Values returned from the database are valid only until a\n\n"]
    pub fn mdb_get(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        key: *mut MDB_val,
        data: *mut MDB_val,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Store items into a database.\n\nThis function stores key/data pairs in the database. The default behavior\nis to enter the new key/data pair, replacing any previously existing key\nif duplicates are disallowed, or adding a duplicate data item if\nduplicates are allowed (#MDB_DUPSORT).\nmust be set to 0 or by bitwise OR'ing together one or more of the\nvalues described here.\n<ul>\n<li>#MDB_NODUPDATA - enter the new key/data pair only if it does not\nalready appear in the database. This flag may only be specified\nif the database was opened with #MDB_DUPSORT. The function will\nreturn #MDB_KEYEXIST if the key/data pair already appears in the\ndatabase.\n<li>#MDB_NOOVERWRITE - enter the new key/data pair only if the key\ndoes not already appear in the database. The function will return\n#MDB_KEYEXIST if the key already appears in the database, even if\nthe database supports duplicates (#MDB_DUPSORT). The \\b data\nparameter will be set to point to the existing item.\n<li>#MDB_RESERVE - reserve space for data of the given size, but\ndon't copy the given data. Instead, return a pointer to the\nreserved space, which the caller can fill in later - before\nthe next update operation or the transaction ends. This saves\nan extra memcpy if the data is being generated later.\nLMDB does nothing else with this memory, the caller is expected\nto modify all of the space requested. This flag must not be\nspecified if the database was opened with #MDB_DUPSORT.\n<li>#MDB_APPEND - append the given key/data pair to the end of the\ndatabase. This option allows fast bulk loading when keys are\nalready known to be in the correct order. Loading unsorted keys\nwith this flag will cause a #MDB_KEYEXIST error.\n<li>#MDB_APPENDDUP - as above, but for sorted dup data.\n</ul>\nerrors are:\n<ul>\n<li>#MDB_MAP_FULL - the database is full, see #mdb_env_set_mapsize().\n<li>#MDB_TXN_FULL - the transaction has too many dirty pages.\n<li>EACCES - an attempt was made to write in a read-only transaction.\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `key` - The key to store in the database [Direction: In]\n* `data` - The data to store [Direction: Out]\n* `flags` - Special options for this operation. This parameter [Direction: In]\n\n"]
    pub fn mdb_put(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        key: *mut MDB_val,
        data: *mut MDB_val,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Delete items from a database.\n\nThis function removes key/data pairs from the database.\nIf the database does not support sorted duplicate data items\n(#MDB_DUPSORT) the data parameter is ignored.\nIf the database supports sorted duplicates and the data parameter\nis NULL, all of the duplicate data items for the key will be\ndeleted. Otherwise, if the data parameter is non-NULL\nonly the matching data item will be deleted.\nThis function will return #MDB_NOTFOUND if the specified key/data\npair is not in the database.\nerrors are:\n<ul>\n<li>EACCES - an attempt was made to write in a read-only transaction.\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `key` - The key to delete from the database [Direction: In]\n* `data` - The data to delete [Direction: In]\n\n"]
    pub fn mdb_del(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        key: *mut MDB_val,
        data: *mut MDB_val,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Create a cursor handle.\n\nA cursor is associated with a specific transaction and database.\nA cursor cannot be used when its database handle is closed. Nor\nwhen its transaction has ended, except with #mdb_cursor_renew().\nIt can be discarded with #mdb_cursor_close().\nA cursor in a write-transaction can be closed before its transaction\nends, and will otherwise be closed when its transaction ends.\nA cursor in a read-only transaction must be closed explicitly, before\nor after its transaction ends. It can be reused with\n#mdb_cursor_renew() before finally closing it.\nwere closed when the transaction committed or aborted.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `cursor` - Address where the new #MDB_cursor handle will be stored [Direction: In, Out]\n\n# Notes\n\n* Earlier documentation said that cursors in every transaction\n\n"]
    pub fn mdb_cursor_open(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        cursor: *mut *mut MDB_cursor,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Close a cursor handle.\n\nThe cursor handle will be freed and must not be used again after this call.\nIts transaction must still be live if it is a write-transaction.\n\n# Arguments\n\n* `cursor` - A cursor handle returned by #mdb_cursor_open() [Direction: In]\n\n"]
    pub fn mdb_cursor_close(cursor: *mut MDB_cursor);
}
extern "C" {
    #[doc = "Renew a cursor handle.\n\nA cursor is associated with a specific transaction and database.\nCursors that are only used in read-only\ntransactions may be re-used, to avoid unnecessary malloc/free overhead.\nThe cursor may be associated with a new read-only transaction, and\nreferencing the same database handle as it was created with.\nThis may be done whether the previous transaction is live or dead.\nerrors are:\n<ul>\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `cursor` - A cursor handle returned by #mdb_cursor_open() [Direction: In]\n\n"]
    pub fn mdb_cursor_renew(txn: *mut MDB_txn, cursor: *mut MDB_cursor) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Return the cursor's transaction handle.\n\n# Arguments\n\n* `cursor` - A cursor handle returned by #mdb_cursor_open() [Direction: In]\n\n"]
    pub fn mdb_cursor_txn(cursor: *mut MDB_cursor) -> *mut MDB_txn;
}
extern "C" {
    #[doc = "Return the cursor's database handle.\n\n# Arguments\n\n* `cursor` - A cursor handle returned by #mdb_cursor_open() [Direction: In]\n\n"]
    pub fn mdb_cursor_dbi(cursor: *mut MDB_cursor) -> MDB_dbi;
}
extern "C" {
    #[doc = "Check if the cursor is pointing to a named database record.\n\nReturns:\n\n* 1 if current record is a named database, 0 otherwise.\n\n# Arguments\n\n* `cursor` - A cursor handle returned by #mdb_cursor_open() [Direction: In]\n\n"]
    pub fn mdb_cursor_is_db(cursor: *mut MDB_cursor) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Retrieve by cursor.\n\nThis function retrieves key/data pairs from the database. The address and length\nof the key are returned in the object to which \\b key refers (except for the\ncase of the #MDB_SET option, in which the \\b key object is unchanged), and\nthe address and length of the data are returned in the object to which \\b data\nrefers.\nSee #mdb_get() for restrictions on using the output values.\nerrors are:\n<ul>\n<li>#MDB_NOTFOUND - no matching key found.\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `cursor` - A cursor handle returned by #mdb_cursor_open() [Direction: In]\n* `key` - The key for a retrieved item [Direction: Out]\n* `data` - The data of a retrieved item [Direction: Out]\n* `op` - A cursor operation #MDB_cursor_op [Direction: In]\n\n"]
    pub fn mdb_cursor_get(
        cursor: *mut MDB_cursor,
        key: *mut MDB_val,
        data: *mut MDB_val,
        op: MDB_cursor_op,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Store by cursor.\n\nThis function stores key/data pairs into the database.\nThe cursor is positioned at the new item, or on failure usually near it.\nstate of the cursor unchanged.\nmust be set to 0 or one of the values described here.\n<ul>\n<li>#MDB_CURRENT - replace the item at the current cursor position.\nThe \\b key parameter must still be provided, and must match it.\nIf using sorted duplicates (#MDB_DUPSORT) the data item must still\nsort into the same place. This is intended to be used when the\nnew data is the same size as the old. Otherwise it will simply\nperform a delete of the old record followed by an insert.\n<li>#MDB_NODUPDATA - enter the new key/data pair only if it does not\nalready appear in the database. This flag may only be specified\nif the database was opened with #MDB_DUPSORT. The function will\nreturn #MDB_KEYEXIST if the key/data pair already appears in the\ndatabase.\n<li>#MDB_NOOVERWRITE - enter the new key/data pair only if the key\ndoes not already appear in the database. The function will return\n#MDB_KEYEXIST if the key already appears in the database, even if\nthe database supports duplicates (#MDB_DUPSORT).\n<li>#MDB_RESERVE - reserve space for data of the given size, but\ndon't copy the given data. Instead, return a pointer to the\nreserved space, which the caller can fill in later - before\nthe next update operation or the transaction ends. This saves\nan extra memcpy if the data is being generated later. This flag\nmust not be specified if the database was opened with #MDB_DUPSORT.\n<li>#MDB_APPEND - append the given key/data pair to the end of the\ndatabase. No key comparisons are performed. This option allows\nfast bulk loading when keys are already known to be in the\ncorrect order. Loading unsorted keys with this flag will cause\na #MDB_KEYEXIST error.\n<li>#MDB_APPENDDUP - as above, but for sorted dup data.\n<li>#MDB_MULTIPLE - store multiple contiguous data elements in a\nsingle request. This flag may only be specified if the database\nwas opened with #MDB_DUPFIXED. The \\b data argument must be an\narray of two MDB_vals. The mv_size of the first MDB_val must be\nthe size of a single data element. The mv_data of the first MDB_val\nmust point to the beginning of the array of contiguous data elements.\nThe mv_size of the second MDB_val must be the count of the number\nof data elements to store. On return this field will be set to\nthe count of the number of elements actually written. The mv_data\nof the second MDB_val is unused.\n</ul>\nerrors are:\n<ul>\n<li>#MDB_MAP_FULL - the database is full, see #mdb_env_set_mapsize().\n<li>#MDB_TXN_FULL - the transaction has too many dirty pages.\n<li>EACCES - an attempt was made to write in a read-only transaction.\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `cursor` - A cursor handle returned by #mdb_cursor_open() [Direction: In]\n* `key` - The key operated on. [Direction: In]\n* `data` - The data operated on. [Direction: In]\n* `flags` - Options for this operation. This parameter [Direction: In]\n\n# Notes\n\n* Earlier documentation incorrectly said errors would leave the\n\n"]
    pub fn mdb_cursor_put(
        cursor: *mut MDB_cursor,
        key: *mut MDB_val,
        data: *mut MDB_val,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Delete current key/data pair\n\nThis function deletes the key/data pair to which the cursor refers.\nThis does not invalidate the cursor, so operations such as MDB_NEXT\ncan still be used on it.\nBoth MDB_NEXT and MDB_GET_CURRENT will return the same record after\nthis operation.\nmust be set to 0 or one of the values described here.\n<ul>\n<li>#MDB_NODUPDATA - delete all of the data items for the current key.\nThis flag may only be specified if the database was opened with #MDB_DUPSORT.\n</ul>\nerrors are:\n<ul>\n<li>EACCES - an attempt was made to write in a read-only transaction.\n<li>EINVAL - an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `cursor` - A cursor handle returned by #mdb_cursor_open() [Direction: In]\n* `flags` - Options for this operation. This parameter [Direction: In]\n\n"]
    pub fn mdb_cursor_del(cursor: *mut MDB_cursor, flags: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Return count of duplicates for current key.\n\nThis call is only valid on databases that support sorted duplicate\ndata items #MDB_DUPSORT.\nerrors are:\n<ul>\n<li>EINVAL - cursor is not initialized, or an invalid parameter was specified.\n</ul>\n\nReturns:\n\n* A non-zero error value on failure and 0 on success. Some possible\n\n# Arguments\n\n* `cursor` - A cursor handle returned by #mdb_cursor_open() [Direction: In]\n* `countp` - Address where the count will be stored [Direction: In, Out]\n\n"]
    pub fn mdb_cursor_count(cursor: *mut MDB_cursor, countp: *mut mdb_size_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Compare two data items according to a particular database.\n\nThis returns a comparison as if the two data items were keys in the\nspecified database.\n\nReturns:\n\n* < 0 if a < b, 0 if a == b, > 0 if a > b\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `a` - The first item to compare [Direction: In]\n* `b` - The second item to compare [Direction: In]\n\n"]
    pub fn mdb_cmp(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        a: *const MDB_val,
        b: *const MDB_val,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Compare two data items according to a particular database.\n\nThis returns a comparison as if the two items were data items of\nthe specified database. The database must have the #MDB_DUPSORT flag.\n\nReturns:\n\n* < 0 if a < b, 0 if a == b, > 0 if a > b\n\n# Arguments\n\n* `txn` - A transaction handle returned by #mdb_txn_begin() [Direction: In]\n* `dbi` - A database handle returned by #mdb_dbi_open() [Direction: In]\n* `a` - The first item to compare [Direction: In]\n* `b` - The second item to compare [Direction: In]\n\n"]
    pub fn mdb_dcmp(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        a: *const MDB_val,
        b: *const MDB_val,
    ) -> ::libc::c_int;
}
#[doc = "A callback function used to print a message from the library.\n\nReturns:\n\n* < 0 on failure, >= 0 on success.\n\n# Arguments\n\n* `msg` - The string to be printed. [Direction: In]\n* `ctx` - An arbitrary context pointer for the callback. [Direction: In]\n\n"]
pub type MDB_msg_func = ::std::option::Option<
    unsafe extern "C" fn(msg: *const ::libc::c_char, ctx: *mut ::libc::c_void) -> ::libc::c_int,
>;
extern "C" {
    #[doc = "Dump the entries in the reader lock table.\n\nReturns:\n\n* < 0 on failure, >= 0 on success.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `func` - A #MDB_msg_func function [Direction: In]\n* `ctx` - Anything the message function needs [Direction: In]\n\n"]
    pub fn mdb_reader_list(
        env: *mut MDB_env,
        func: MDB_msg_func,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Check for stale entries in the reader lock table.\n\nReturns:\n\n* 0 on success, non-zero on failure.\n\n# Arguments\n\n* `env` - An environment handle returned by #mdb_env_create() [Direction: In]\n* `dead` - Number of stale slots that were cleared [Direction: In, Out]\n\n"]
    pub fn mdb_reader_check(env: *mut MDB_env, dead: *mut ::libc::c_int) -> ::libc::c_int;
}
#[doc = "A function for converting a string into an encryption key.\n\nprovide the space for the key.\n\nReturns:\n\n* 0 on success, non-zero on failure.\n\n# Arguments\n\n* `passwd` - The string to be converted. [Direction: In]\n* `key` - The resulting key. The caller must [Direction: Out]\n\n"]
pub type MDB_str2key_func = ::std::option::Option<
    unsafe extern "C" fn(passwd: *const ::libc::c_char, key: *mut MDB_val) -> ::libc::c_int,
>;
#[doc = "A structure for dynamically loaded crypto modules.\n\nThis is the information that the command line tools expect\nin order to operate on encrypted or checksummed environments.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_crypto_funcs {
    pub mcf_str2key: MDB_str2key_func,
    pub mcf_encfunc: MDB_enc_func,
    pub mcf_sumfunc: MDB_sum_func,
    #[doc = "The size of an encryption key, in bytes\n\n"]
    pub mcf_keysize: ::libc::c_int,
    #[doc = "The size of the MAC, for authenticated encryption\n\n"]
    pub mcf_esumsize: ::libc::c_int,
    #[doc = "The size of the checksum, for plain checksums\n\n"]
    pub mcf_sumsize: ::libc::c_int,
}
#[doc = "The function that returns the #MDB_crypto_funcs structure.\n\nThe command line tools expect this function to be named \"MDB_crypto\".\nIt must be exported by the dynamic module so that the tools can use it.\n\nReturns:\n\n* A pointer to a #MDB_crypto_funcs structure.\n\n"]
pub type MDB_crypto_hooks = ::std::option::Option<unsafe extern "C" fn() -> *mut MDB_crypto_funcs>;
